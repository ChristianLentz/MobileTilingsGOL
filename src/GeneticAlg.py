# =======================================================

"""
A genetic algorithm to evolve tilings within Conway's Game
of Life. This Algorithm is based/adapted from Model-S, from 
Peter D. Turney: 

https://github.com/pdturney/modeling-symbiosis-revised

Note that this class only contains each of the pieces 
needed for a GA, which are used in the GAManager class
in RunSim.py. 

We provide two underlying implementations of life, 
deterministic and stochastic. See runSim.py file for more. 

Our genetic algorithm has a tiered reproduction system, which 
includes asexual and sexual reproductions. 

We evaluate fitness based on straight-line movement, similar 
to that of glider tilings.  

Authors: Christian Lentz, Ana Espeleta
"""

# =======================================================

import copy
import numpy as np
import random as rand 
from tileAgent import Seed

# =======================================================

class GA:
    
    """
    A genetic algorithm for evolving tile agents within the Game of Life. 
    This class produces a new population of agents from a provided population.
    
    Much of this code is modeled after / adapted from two sources: 
    
    1) Macaelster College Intro to Artificial Intelligence curriculum 
    2) Model-S, Peter D. Turney 
    """ 

    def __init__(self, population):
        
        """
        Constructor for the GAStep class.
        """ 
        
        self.pop = population 
        self.prev_avg_fit = None
        self.mutation_rate = 0.01
        self.max_mut_rate = 0.07

    def uniform_asexual(self, candidate_seed):
        
        """
        Create a new seed by randomly mutating an existing seed. The
        new seed is generated by selecting a parent seed and flipping
        bits in the parent. The size of the seed does not change; it
        is uniform.
        """
        
        # parent/candidate is the most fit member of the population 
        s0 = candidate_seed
        # make a copy of the parent and mutate it to make a new child 
        s1 = Seed(s0.xSpan, s0.ySpan, len(self.pop))
        s1.cells = s0.cells
        s1.area = s0.area
        s1.mutate(self.mutation_rate)
        # Find the least fit seed (replace)
        s2 = self.find_worst_seed(self.pop)
        # Replace least fit seed with new child
        i = s2.address
        s1.address = i 
        self.pop[i] = s1 
        # Report parent and replaced seed 
        print(f"Parent fitness: {s0.fitness}")
        print(f"Replaced seed fitness: {s2.fitness}")

        # Update similarities
        for j in range(len(self.pop)):
            self.update_similarity(self.pop, i, j)

        # return the new child
        return self.pop[i]
    
    def find_worst_seed(self, sample):
        
        """
        In the list of seeds in population, find the seed (not necessarily
        unique) with minimum fitness.
        """
        
        worst_seed = sample[0]
        worst_score = worst_seed.fitness
        for i in range(len(sample)):
            if (sample[i].fitness < worst_score):
                worst_seed = sample[i]
                worst_score = worst_seed.fitness
        return worst_seed
    
    def roulette_select(self, pop):
        
        """Choose members of current population with a probability proportional 
        to fitness."""
        
        # sum the total fitness of the population 
        total_fit = 0
        
        for i in range(len(pop)):
            total_fit += pop[i].fitness

        # scale fitness of each agent to a probability in (0, 1) 
        scaled_fitness = []
        
        for ind in pop:
            ind_fit = ind.fitness/total_fit
            scaled_fitness.append(ind_fit)

        # perform the roulette selection 
        rand_val = rand.random()
        index = 0

        increm_fit = scaled_fitness[index]
        while ((index < len(pop)-1) and (rand_val > increm_fit)):
            index += 1
            increm_fit += scaled_fitness[index]
        # return an index into the population array to choose the parent from 
        return index  
  
    def mate(self, seed0, seed1):
        
        """
        Apply crossover to seed0 and seed1. We only have one crossover point,
        because multiple crossover points would be more disruptive to the
        structure of the seeds.
        """
        # Take the minimum for the xSpan and the ySpan

        # Note the spans of seed0 and seed1. We select the minimum spans between the two seeds to simplify process
        xSpan = min(seed0.xSpan, seed1.xSpan)
        ySpan = min(seed0.ySpan, seed1.ySpan)

        # Randomly swap the seeds to add some variety
        if (rand.uniform(0, 1) < 0.5):
            s0 = seed0
            s1 = seed1
        else:
            s0 = seed1
            s1 = seed0

        # Initialize the child to zero.
        child_seed = Seed(xSpan, ySpan, len(self.pop)) 
        
        # Randomly choose whether to split on the X axis or
        # the Y axis.
        if (rand.uniform(0, 1) < 0.5):
            # Choose the Y axis split point. There will always be
            # at least one row on either side of the split point.
            assert ySpan > 1
            y_split_point = rand.randrange(ySpan - 1)
            for x in range(xSpan):
                for y in range(ySpan):
                    if (y <= y_split_point):
                        child_seed.cells[x][y] = s0.cells[x][y]
                    else:
                        child_seed.cells[x][y] = s1.cells[x][y]
        else:
            # Choose the X axis split point. There will always be
            # at least one column on either side of the split point.
            assert xSpan > 1
            x_split_point = rand.randrange(xSpan - 1)
            for x in range(xSpan):
                for y in range(ySpan):
                    if (x <= x_split_point):
                        child_seed.cells[x][y] = s0.cells[x][y]
                    else:
                        child_seed.cells[x][y] = s1.cells[x][y]
        
        # Return the resulting child.
        return child_seed

    def similarity(self, seed0, seed1):
        """
        Measure the bit-wise similarity of two seeds.
        """

        # Initialize count.
        num_agree = 0.0

        # Get the min spans 
        xSpan = min(seed0.xSpan, seed1.xSpan)
        ySpan = min(seed0.ySpan, seed1.ySpan)

        # Count agreements.
        for x in range(xSpan):
            for y in range(ySpan):
                if (seed0.cells[x][y] == seed1.cells[x][y]):
                    num_agree = num_agree + 1.0
        
        # Calculate a similarity score ranging from zero to one.        
        similarity = num_agree / (xSpan * ySpan)
      
        # Return the degree of similarity between the two seeds.
        return similarity

    def update_similarity(self, pop, i, j):
        """
        Calculate the similarity between the two given seeds and 
        update their internal records with the result.
        """
        
        # If i == j, the similarity score is the maximum.        
        if (i == j):
            pop[i].similarities[i] = 1.0
            return
        
        # Calculate the similarity and update the population record.        
        sim = self.similarity(pop[i], pop[j])
  
        pop[i].similarities[j] = sim
        pop[j].similarities[i] = sim

    def find_similar_seeds(self, target_seed, pop, min_similarity, max_similarity):
        """
        Given a target seed, find seeds in the population with similarities
        to the target in the range from min_similarity to max_similarity.
        This function assumes that target_seed is in the population and
        the list target_seed.similarities is up-to-date. 
        """
        similar_seeds = []
        for i in range(len(pop)):
            for j in range(len(pop)):
                self.update_similarity(self.pop, i, j)
            if ((target_seed.similarities[i] >= min_similarity) and \
            (target_seed.similarities[i] <= max_similarity) and \
            (target_seed.address != i)): # edit this to avoid equal scores
                similar_seeds.append(pop[i])

        # return the seeds that satisfy the conditions
        return similar_seeds

    def sexual_similarity(self, candidate_seed):
        """
        Create a new seed either asexually or sexually. First a single parent
        is chosen from the population. If a second parent can be found that
        is sufficiently similar to the first parent, then the child will have
        two parents (sexual reproduction). If no similar second parent can be
        found, then the child will have one parent (asexual reproduction).
        """
       
        # Let s0 be the most fit member of the tournament.
        s0 = candidate_seed

        # Find similar seeds in the population (members of the same species).
        min_similarity = 0.6
        max_similarity = 0.9
        similar_seeds = self.find_similar_seeds(s0, self.pop, min_similarity, max_similarity)
        num_similar_seeds = len(similar_seeds)
        
        # If no similar seeds were found, then use variable asexual reproduction.
        if (num_similar_seeds == 0):
            return self.uniform_asexual(s0)
        
        # else:
        s1 = self.pop[self.roulette_select(similar_seeds)]

        # Mate the parents to make a new child.
        s2 = self.mate(s0, s1)
        # Mutate the child.
        s3 = Seed(s2.xSpan, s2.ySpan, len(self.pop))
        s3.cells = s2.cells
        s3.mutate(self.mutation_rate)
        
        # Find the least fit old seed in the population. 
        s4 = self.find_worst_seed(self.pop)
        
        # Replace the least fit old seed in the population (s4) with the
        # new child (s3).
        i = s4.address # find the position of the old seed (s4)
        s3.address = i # copy the old position of the old seed into s3, the child
        self.pop[i] = s3 # replace s4 (old seed) in population (pop) with s3 (new child)

        # update seed similarities
        for j in range(len(self.pop)):
            self.update_similarity(self.pop, i, j)

        print(f"Parent1 fitness: {s0.fitness}")
        print(f"Parent2 fitness: {s1.fitness}")
        print(f"Replaced seed fitness: {s4.fitness}")          

        return self.pop[i]

    def sexual(self, candidate_seed):
        """
        Create a new seed either asexually or sexually. First a single parent
        is chosen from the population. If a second parent can be found that
        is sufficiently similar to the first parent, then the child will have
        two parents (sexual reproduction). If no similar second parent can be
        found, then the child will have one parent (asexual reproduction).
        """
       
        # Select parents through roulette selection
        s0 = candidate_seed        
        s1 = self.pop[self.roulette_select(self.pop)]

        # Mate the parents to make a new child.
        s2 = self.mate(s0, s1)
        # Mutate the child.
        s3 = Seed(s2.xSpan, s2.ySpan, len(self.pop))
        s3.cells = s2.cells
        s3.mutate(self.mutation_rate)
        # Find the least fit old seed in the population. It's not a problem
        # if there are ties.
        s4 = self.find_worst_seed(self.pop)
        
        # Replace the least fit old seed in the population (s4) with the
        # new child (s3).
        i = s4.address # find the position of the old seed (s4)
        s3.address = i # copy the old position of the old seed into s3, the child
        self.pop[i] = s3 # replace s4 (old seed) in population (pop) with s3 (new child)

        # update seed similarities
        for j in range(len(self.pop)):
            self.update_similarity(self.pop, i, j)

        print(f"Parent1 fitness: {s0.fitness}")
        print(f"Parent2 fitness: {s1.fitness}")
        print(f"Replaced seed fitness: {s4.fitness}")          

        return self.pop[i]
    
    def alter_mutation_rate(self, avg_fit):
        
        """
        Given the average fitness of the current population, alter the
        mutation rate in proportion to how much the average fitness of 
        the populationhas changed in the previous five steps. 

        If the average fitness has changed little in the prevous five
        steps, then the mution rate will be hihger. 
        """
        
        if self.prev_avg_fit != None:  
            percent_change = abs(1 - (avg_fit / self.prev_avg_fit))
            alpha = 1 - percent_change
            self.mutation_rate = alpha * self.max_mut_rate
            self.prev_avg_fit = avg_fit